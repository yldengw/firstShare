<div class="post-detail-container" *ngIf=" title=='angular' && article.angular">
  <div class="row">
    <div class="col-sm-12">
      <h4>{{ article.angular.title }}</h4>
      <p>{{ article.angular.author }} {{ article.angular.postTime }} 点击：{{ article.angular.readTimes }} 评论：{{ article.HTML5.commentTimes
        }}</p>
    </div>
  </div>
  <div class="row">
    <div class="col-sm-12" [innerHTML]="article.angular.text">
    </div>
  </div>
</div>
<div class="post-detail-container" *ngIf=" title=='HTML5' && article.HTML5">
  <div class="row">
    <div class="col-sm-12">
      <h4>{{ article.HTML5.title }}</h4>
      <p>{{ article.HTML5.author }} {{ article.HTML5.postTime }} 点击：{{ article.HTML5.readTimes }} 评论：{{ article.HTML5.commentTimes
        }}</p>
    </div>
  </div>
  <div class="row">
    <div class="col-sm-12" [innerHTML]="article.HTML5.text">
    </div>
  </div>
  <!--canvas绘制 start-->
  <div align="center">
    <canvas id="myCanvas" width="500" height="200" style="border:2px solid #6699cc"></canvas>
    <div class="control-ops">
      <button type="button" class="btn btn-primary" onclick="javascript:clearArea();return false;">清空画板</button>
      Line width :
      <select id="selWidth">
        <option value="1">1</option>
        <option value="3">3</option>
        <option value="5">5</option>
        <option value="7">7</option>
        <option value="9" selected="selected">9</option>
        <option value="11">11</option>
      </select>
      Color :
      <select id="selColor">
        <option value="black">black</option>
        <option value="blue" selected="selected">blue</option>
        <option value="red">red</option>
        <option value="green">green</option>
        <option value="yellow">yellow</option>
        <option value="gray">gray</option>
      </select>
    </div>
  </div>
  <!--canvas绘制 end-->
</div>
 <div class="post-detail-container" *ngIf=" title=='CSS3' && article.CSS3">
  <div class="row">
    <div class="col-sm-12">
      <h4>{{ article.CSS3.title }}</h4>
      <p>{{ article.CSS3.author }} {{ article.CSS3.postTime }} 点击：{{ article.CSS3.readTimes }} 评论：{{ article.HTML5.commentTimes
        }}</p>
    </div>
  </div>
  <div class="row">
    <div class="col-sm-12" [innerHTML]="article.CSS3.text">
    </div>
  </div>
  <div class="row">
    <div class="col-sm-12">
      cookie，sessionStorage，localeStorage的区别
      <br/> cookie是存储在浏览器端， 并且随浏览器的请求一起发送到服务器端的，它有一定的过期时间， 到了过期时间自动会消失
      <br/> sessionStorage和localeStorage也是存储在客户端的，同属于web Storage，比cookie的存储大小要大有8m，cookie只有4kb， localeStorage是持久化的存储在客户端，如果用户不手动清除的话，不会自动消失，
      会一直存在，sessionStorage也是存储在客户端， 但是它的存活时间是在一个回话期间，只要浏览器的回话关闭了就会自动消失
    </div>
  </div>
</div>
 <div class="post-detail-container" *ngIf=" title=='Javascript' && article.Javascript">
  <div class="row">
    <div class="col-sm-12">
      <h4>{{ article.Javascript.title }}</h4>
      <p>{{ article.Javascript.author }} {{ article.Javascript.postTime }} 点击：{{ article.Javascript.readTimes }} 评论：{{ article.Javascript.commentTimes
        }}</p>
    </div>
  </div>
  <div class="row">
    <div class="col-sm-12" [innerHTML]="article.Javascript.text">
    </div>
  </div>
  <div class="row">
    <div class="col-sm-12">
      1、闭包
      <img src="./assets/img/bibao.png"> 当函数a的内部函数b被函数a外的一个变量引用的时候，就创建了一个闭包
      <br/> 闭包的作用就是在a执行完并返回后，闭包使得Javascript的垃圾回收机制GC不会收回a所占用的资源，因为a的内部函数b的执行需要依赖a中的变量
      <br/> Javascript的垃圾回收机制
      <br/> 在Javascript中，如果一个对象不再被引用，那么这个对象就会被GC回收。如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。因为函数a被b引用，b又被a外的c引用，这就是为什么函数a执行后不会被回收的原因。
    </div>
  </div>
  <div class="col-sm-12">
    2、网页布局 a、静态布局 <br/> 
    不管浏览器尺寸具体是多少，网页布局就按照当时写代码的布局来布置,在屏幕宽高有调整时，使用横向和竖向的滚动条来查阅被遮掩部分<br/>
     b、弹性布局 <br/> 
     其中flex-flow是flex-direction和flex-wrap属性的简写方式，语法如下：<br/>
      flex-flow:
    <!-- <flex-direction> ||
      <flex-wrap></flex-wrap> -->
      flex-direction: row（初始值） | row-reverse | column | column-reverse flex-wrap: nowrap（初始值） | wrap | wrap-reverse flex-direction定义了弹性项目在弹性容器中的放置方向，默认是row，即行内方向（一般而言是由左往右，但注意这个和书写模式有关）。
      flex-wrap定义是否需要拆行以使得弹性项目能被容器包含。*-reverse代表相反的方向。 两者结合起来即flex-flow属性就确定了弹性容器在main axis和cross axis两个方向上的显示方式 <br/> 3、自适应布局
      <br/> 分别为不同的屏幕分辨率定义布局。布局切换时页面元素发生改变，但在每个布局中，页面元素不随窗口大小的调整发生变化。  你可以把自适应布局看作是静态布局的一个系列。  就是说你看到的页面，里面元素的位置会变化而大小不会变化
      <br/> 4、流式布局
      <br/> 是页面元素的宽度按照屏幕进行适配调整，主要的问题是如果屏幕尺度跨度太大，那么在相对其原始设计而言过小或过大的屏幕上不能正常显示  你看到的页面，元素的大小会变化而位置不会变化——这就导致如果屏幕太大或者太小都会导致元素无法正常显示。
      <br/> 5、响应式布局
      <br/> 分别为不同的屏幕分辨率定义布局，同时，在每个布局中，应用流式布局的理念，即页面元素宽度随着窗口调整而自动适配。  可以把响应式布局看作是流式布局和自适应布局设计理念的融合。  每个屏幕分辨率下面会有一个布局样式，同时位置会变而且大小也会变
      <br/>
  </div>
</div> 
<div class="post-detail-container" *ngIf=" title=='angular' && article.angular">
  <div class="row">
    <div class="col-sm-12">
      <h4>{{ article.angular.title }}</h4>
      <p>{{ article.angular.author }} {{ article.angular.postTime }} 点击：{{ article.angular.readTimes }} 评论：{{ article.HTML5.commentTimes
        }}</p>
    </div>
  </div>
  <div class="row">
    <div class="col-sm-12" [innerHTML]="article.angular.text">
    </div>
  </div>
</div>
<div class="post-detail-container" *ngIf=" title=='HTML5' && article.HTML5">
  <div class="row">
    <div class="col-sm-12">
      <h4>{{ article.HTML5.title }}</h4>
      <p>{{ article.HTML5.author }} {{ article.HTML5.postTime }} 点击：{{ article.HTML5.readTimes }} 评论：{{ article.HTML5.commentTimes
        }}</p>
    </div>
  <div class="row">
    <div class="col-sm-12" [innerHTML]="article.HTML5.text">
    </div>
  </div>
  <!--canvas绘制 start-->
  <div align="center">
    <canvas id="myCanvas" width="500" height="200" style="border:2px solid #6699cc"></canvas>
    <div class="control-ops">
      <button type="button" class="btn btn-primary" onclick="javascript:clearArea();return false;">清空画板</button>
      Line width :
      <select id="selWidth">
        <option value="1">1</option>
        <option value="3">3</option>
        <option value="5">5</option>
        <option value="7">7</option>
        <option value="9" selected="selected">9</option>
        <option value="11">11</option>
      </select>
      Color :
      <select id="selColor">
        <option value="black">black</option>
        <option value="blue" selected="selected">blue</option>
        <option value="red">red</option>
        <option value="green">green</option>
        <option value="yellow">yellow</option>
        <option value="gray">gray</option>
      </select>
    </div>
  </div>
  <!--canvas绘制 end-->
</div>
<div class="post-detail-container" *ngIf=" title=='CSS3' && article.CSS3">
  <div class="row">
    <div class="col-sm-12">
      <h4>{{ article.CSS3.title }}</h4>
      <p>{{ article.CSS3.author }} {{ article.CSS3.postTime }} 点击：{{ article.CSS3.readTimes }} 评论：{{ article.HTML5.commentTimes
        }}</p>
    </div>
  </div>
  <div class="row">
    <div class="col-sm-12" [innerHTML]="article.CSS3.text">
    </div>
  </div>
  <div class="row">
    <div class="col-sm-12">
      cookie，sessionStorage，localeStorage的区别
      <br/> cookie是存储在浏览器端， 并且随浏览器的请求一起发送到服务器端的，它有一定的过期时间， 到了过期时间自动会消失
      <br/> sessionStorage和localeStorage也是存储在客户端的，同属于web Storage，比cookie的存储大小要大有8m，cookie只有4kb， localeStorage是持久化的存储在客户端，如果用户不手动清除的话，不会自动消失，
      会一直存在，sessionStorage也是存储在客户端， 但是它的存活时间是在一个回话期间，只要浏览器的回话关闭了就会自动消失
    </div>
  </div>
</div>
<div class="post-detail-container" *ngIf=" title=='Javascript' && article.Javascript">
  <div class="row">
    <div class="col-sm-12">
      <h4>{{ article.Javascript.title }}</h4>
      <p>{{ article.Javascript.author }} {{ article.Javascript.postTime }} 点击：{{ article.Javascript.readTimes }} 评论：{{ article.Javascript.commentTimes
        }}</p>
    </div>
  </div>
  <div class="row">
    <div class="col-sm-12" [innerHTML]="article.Javascript.text">
    </div>
  </div>
  <div class="row">
    <div class="col-sm-12">
      1、闭包
      <img src="./assets/img/bibao.png"> 当函数a的内部函数b被函数a外的一个变量引用的时候，就创建了一个闭包
      <br/> 闭包的作用就是在a执行完并返回后，闭包使得Javascript的垃圾回收机制GC不会收回a所占用的资源，因为a的内部函数b的执行需要依赖a中的变量
      <br/> Javascript的垃圾回收机制
      <br/> 在Javascript中，如果一个对象不再被引用，那么这个对象就会被GC回收。如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。因为函数a被b引用，b又被a外的c引用，这就是为什么函数a执行后不会被回收的原因。
    </div>
  </div>
  <!-- <div class="col-sm-12">
    2、网页布局 a、静态布局
    <br/> 不管浏览器尺寸具体是多少，网页布局就按照当时写代码的布局来布置,在屏幕宽高有调整时，使用横向和竖向的滚动条来查阅被遮掩部分
    <br/> b、弹性布局
    <br/> 其中flex-flow是flex-direction和flex-wrap属性的简写方式，语法如下：
    <br/> flex-flow:
    flex-direction ||
      flex-wrap /flex-wrap
      flex-direction: row（初始值） | row-reverse | column | column-reverse flex-wrap: nowrap（初始值） | wrap | wrap-reverse flex-direction定义了弹性项目在弹性容器中的放置方向，默认是row，即行内方向（一般而言是由左往右，但注意这个和书写模式有关）。
      flex-wrap定义是否需要拆行以使得弹性项目能被容器包含。*-reverse代表相反的方向。 两者结合起来即flex-flow属性就确定了弹性容器在main axis和cross axis两个方向上的显示方式
      <br/> 3、自适应布局
      <br/> 分别为不同的屏幕分辨率定义布局。布局切换时页面元素发生改变，但在每个布局中，页面元素不随窗口大小的调整发生变化。  你可以把自适应布局看作是静态布局的一个系列。  就是说你看到的页面，里面元素的位置会变化而大小不会变化
      <br/> 4、流式布局
      <br/> 是页面元素的宽度按照屏幕进行适配调整，主要的问题是如果屏幕尺度跨度太大，那么在相对其原始设计而言过小或过大的屏幕上不能正常显示  你看到的页面，元素的大小会变化而位置不会变化——这就导致如果屏幕太大或者太小都会导致元素无法正常显示。
      <br/> 5、响应式布局
      <br/> 分别为不同的屏幕分辨率定义布局，同时，在每个布局中，应用流式布局的理念，即页面元素宽度随着窗口调整而自动适配。  可以把响应式布局看作是流式布局和自适应布局设计理念的融合。  每个屏幕分辨率下面会有一个布局样式，同时位置会变而且大小也会变
      <br/>
  </div> -->
</div>